## 非路由和路由组件的搭建

两个非路由组件：Header 、Footer
路由组件:Home、Search、Login（没有底部的Footer组件，带有二维码的）、Register（没有底部的Footer组件，带二维码的）

<mark>安装路由</mark>

> npm install --legacy-peer-deps [vue-router@3.5.2](mailto:vue-router@3.5.2)

<mark>创建路由组件</mark>【一般放在views|pages文件夹】
<mark>配置路由</mark>，配置完四个路由组件

> 创建非路由组件（2个：Header、Footer）
> 
> 项目采用的less样式,浏览器不识别less语法，需要一些loader进行处理，把less语法转换为CSS语法
> 
> 1：安装less less-loader@5，切记less-loader安装5版本的
> 
> 2:需要在style标签的身上加上lang="less",不添加样式不生效

点击搜索按钮跳转到search组件:编程式路由跳转

Footer组件的显示和隐藏：通过meta路由源信息

Header组件给Search组件传递参数：用data里的一个数据保存用户输入，然后再传递，有三种方法：

<img src="file:///C:/Users/10153/AppData/Roaming/marktext/images/2022-03-28-20-08-50-image.png" title="" alt="" width="577">

路由传参相关的面试题：

1. 在路由传参的对象写法中，如果要使用params参数，就不能用`path`，而是要用`name`

2. 如何指定params参数可传可不传？

3. 路由可不可以通过props传参（用$router.param.keyword来接收参数太麻烦了），可以

## 搜索按钮多次点击报错

因为vue-router的新版本引入了promise，push方法返回一个promise对象，而promise对象需要传入成功和失败的回调

解决？需要重写VueRouter原型上的push和replace方法

```js
const originPush = VueRouter.prototype.push

VueRouter.prototype.push = function (location, resolve, reject) {
    if (resolve && reject) {
        // 如果直接调用,this指向window,所以需要用call来绑定this
        originPush.call(this, location, resolve, reject)
    } else {
        originPush.call(this, location, () => { }, () => { })
    }
}
```

1. 先把静态页面完成，

2. 再拆分出静态组件，

3. 再获取服务器数据进行展示，

4. 再进行动态业务

## 拆分全局组件

如果组件在很多组件都要使用，拆分为全局组件

在main.js入口文件里面全局引入：

```js
// 全局引入三级联动 TypeNav组件,
import TypeNav from './pages/Home/TypeNav/index.vue'
// 第一个参数是组件的名字,第二个参数是哪一个组件
Vue.component(TypeNav.name, TypeNav)
```

接下来直接使用就可以，不用再引入和注册

## postman

所有接口的前缀都有/api，使用前先用postman测试可不可以正常使用

## 二次封装axios

安装`  npm install axios -S `

在路径`src/api`下面创建request.js文件

why？为了增加请求拦截器和相应拦截器，当发起请求前和收到响应后进行一些业务操作

```js
// 对axios进行二次封装
import axios from 'axios'

// 创建一个axios实例（？
const requests = axios.create({
    // 设置发送请求的baseURL
    baseURL: '/api',
    // 隔了5s还没收到响应就认为请求超时
    timeout: 5000
})

// 请求拦截器
requests.interceptors.request.use((config) => {
    // config是一个配置对象,该对象里有请求头headers
    return config
})

// 响应拦截器
requests.interceptors.response.use((res) => {
    // 响应成功的回调函数
    return res.data
}, (error) => {
    // 响应失败的回调函数
    return Promise.reject(new Error(error))
})

export default axios
```

## 接口统一管理

在路径`src/api`下面创建index.js文件

```js
// 这个模块对API的请求进行统一管理

// 引入之前做了封装的axios
import requsts from '../api/request'

// 目的是为了在别的组件里面调用函数直接发起请求，所以对外暴露一个函数
// 请求三级联动接口 /api/product/getBaseCategoryList get 无参数
export const reqCategoryList = () => {
    // 返回一个promise类型的对象
    return requsts({ url: '/product/getBaseCategoryList', method: 'get' })
}
```

## nprogress进度条的使用

安装`npm install --save nprogress`

引入

```js
//在src/api/request.js里
// 引入nprogress进度条和进度条样式
import nprogress from 'nprogress'
import "nprogress/nprogress.css"
```

## Vuex模块式开发

本来state中存储all数据，但是可以把大仓库拆分成多个小仓库，然后import到大仓库里，通过modules配置项来合并

## TypeNav三级联动动态展示

（先把全局组件放到components里面

踩坑：

1. 注意小仓库和大仓库向外暴露的方式都是默认暴露

2. 注意大仓库创建时是Vue.Store

3. 业务相关操作在actions里面，只有这里可以进行异步操作
   
   ```js
   const actions = {
       // 利用API向服务器发送请求
       async getCategory(context) {
           context.commit('GETCATEGORY', (await reqCategoryList()).data)
       }
   }
   ```
